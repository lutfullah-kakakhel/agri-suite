# /opt/irrigation-api/app/main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
import httpx, math, time

from .db import Base, engine, SessionLocal, init_pragmas
from .models import Field as FieldModel
from .schemas import FieldCreate, FieldOut

app = FastAPI(title="Irrigation Advisory API (SQLite + Bilingual Messages)")

# ---------- DB session plumbing ----------
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.on_event("startup")
def on_startup():
    # Create tables and set SQLite PRAGMAs
    Base.metadata.create_all(bind=engine)
    init_pragmas()

# ---------- Health ----------
@app.get("/healthz")
def healthz():
    return {"ok": True}

# ---------- Input model for the raw-advice endpoint ----------
class FieldIn(BaseModel):
    name: str
    crop: str
    centroid_lat: float
    centroid_lon: float
    last_irrigation_ts: int | None = None  # unix seconds

# ---------- ET0 helpers ----------
def et0_fao56_daily(tmin, tmax, rh_mean, u2, rs, lat_deg, doy):
    """
    FAO-56 Penman-Monteith daily reference ET0 (mm/day).
    tmin/tmax (°C), rh_mean (%), u2 (m/s at 2m), rs (MJ/m2/day approx),
    lat_deg (degrees), doy (1..365/366)
    """
    lat = math.radians(lat_deg)
    tmean = (tmin + tmax) / 2.0

    # saturation vapour pressure (kPa)
    es_tmin = 0.6108 * math.exp((17.27 * tmin) / (tmin + 237.3))
    es_tmax = 0.6108 * math.exp((17.27 * tmax) / (tmax + 237.3))
    es = (es_tmin + es_tmax) / 2.0
    # actual vapour pressure (kPa)
    ea = es * (rh_mean / 100.0)

    # slope of vapour pressure curve (kPa/°C)
    delta = 4098 * (0.6108 * math.exp((17.27 * tmean) / (tmean + 237.3))) / ((tmean + 237.3) ** 2)

    # psychrometric constant (kPa/°C) (sea level approx)
    P = 101.3 * (((293 - 0.0065 * 0) / 293) ** 5.26)
    gamma = 0.000665 * P

    # extraterrestrial radiation (Ra, MJ/m2/day)
    dr = 1 + 0.033 * math.cos(2 * math.pi / 365 * doy)
    delta_s = 0.409 * math.sin(2 * math.pi / 365 * doy - 1.39)
    ws = math.acos(-math.tan(lat) * math.tan(delta_s))
    Gsc = 0.0820  # MJ m-2 min-1
    Ra = (24 * 60 / math.pi) * Gsc * dr * (
        ws * math.sin(lat) * math.sin(delta_s) + math.cos(lat) * math.cos(delta_s) * math.sin(ws)
    )

    # convert W/m2 hourly mean to MJ/m2/day approx via 0.0864 factor
    R_s = rs * 0.0864
    Rns = (1 - 0.23) * R_s
    Rso = (0.75 + 2e-5 * 0) * Ra

    sigma = 4.903e-9
    tK4 = ((tmax + 273.16) ** 4 + (tmin + 273.16) ** 4) / 2
    Rnl = sigma * tK4 * (0.34 - 0.14 * math.sqrt(max(ea, 1e-6))) * (1.35 * min(R_s / max(Rso, 1e-6), 1.0) - 0.35)

    Rn = Rns - Rnl  # MJ/m2/day

    et0 = (0.408 * delta * Rn + gamma * (900 / (tmean + 273)) * u2 * (es - ea)) / (delta + gamma * (1 + 0.34 * u2))
    return max(et0, 0.0)

async def fetch_weather(lat, lon):
    url = ("https://api.open-meteo.com/v1/forecast"
           f"?latitude={lat}&longitude={lon}"
           "&hourly=temperature_2m,relative_humidity_2m,wind_speed_10m,shortwave_radiation"
           "&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,precipitation_probability_max"
           "&timezone=Asia%2FKarachi")
    async with httpx.AsyncClient(timeout=30) as cx:
        r = await cx.get(url)
        r.raise_for_status()
        return r.json()

def make_advice_payload(name, crop, lat, lon, last_irrig_ts, wx):
    daily = wx["daily"]; hourly = wx["hourly"]

    tmin = float(daily["temperature_2m_min"][0])
    tmax = float(daily["temperature_2m_max"][0])
    rain = float(daily["precipitation_sum"][0])
    rain_prob = int(daily["precipitation_probability_max"][0])

    rh_mean = sum(map(float, hourly["relative_humidity_2m"][:24])) / 24
    u10 = sum(map(float, hourly["wind_speed_10m"][:24])) / 24
    # Convert 10m wind to 2m wind (log wind profile)
    u2 = u10 * (4.87 / math.log(67.8 * 10 - 5.42))
    rs = sum(map(float, hourly["shortwave_radiation"][:24])) / 24

    et0 = round(et0_fao56_daily(tmin, tmax, rh_mean, u2, rs, lat, int(time.strftime("%j"))), 1)

    # irrigation history
    last = last_irrig_ts or int(time.time()) - 3 * 86400
    days = max(1, (int(time.time()) - last) // 86400)
    cum_et = round(et0 * min(days, 3), 1)
    deficit = round(cum_et - rain, 1)

    # ---------- bilingual messages ----------
    messages = []
    if rain_prob >= 40:
        messages.append({
            "ur": "بارش کا امکان زیادہ ہے (24h): آبپاشی اور سپرے مؤخر کریں۔",
            "en": "High chance of rain (24h): postpone irrigation and spraying."
        })

    if deficit >= 30 and rain_prob < 30:
        messages.append({
            "ur": "پانی کی کمی ~30mm سے زیادہ: اگلے 24–48 گھنٹے میں آبپاشی کریں۔",
            "en": "Water deficit exceeds ~30 mm: irrigate within 24–48 hours."
        })

    if not messages:
        messages.append({
            "ur": "صورتحال معمول کی ہے: اگلے موسم کی پیش گوئی پر نظر رکھیں۔",
            "en": "Conditions are normal: monitor upcoming forecasts."
        })

    return {
        "field": name,
        "crop": crop,
        "today": {
            "tmin_c": tmin,
            "tmax_c": tmax,
            "rain_mm": rain,
            "rain_prob_pct": rain_prob,
            "et0_mm": et0
        },
        "since_last_irrigation_days": int(days),
        "net_deficit_mm": deficit,
        "messages": messages
    }

# ---------- Original raw-advice endpoint (kept) ----------
@app.post("/api/advice")
async def advice_raw(f: FieldIn):
    wx = await fetch_weather(f.centroid_lat, f.centroid_lon)
    return make_advice_payload(f.name, f.crop, f.centroid_lat, f.centroid_lon, f.last_irrigation_ts, wx)

# ---------- Fields CRUD + advice-by-id ----------
#@app.post("/fields", response_model=FieldOut)
#def create_field(payload: FieldCreate, db: Session = Depends(get_db)):
#    field = FieldModel(
#        name=payload.name,
#        crop=payload.crop,
#        centroid_lat=payload.centroid_lat,
#        centroid_lon=payload.centroid_lon,
#        polygon_geojson=payload.polygon_geojson,
#        last_irrigation_ts=payload.last_irrigation_ts
#    )
#    db.add(field)
#    db.commit()
#    db.refresh(field)
#    return field

#@app.get("/fields", response_model=list[FieldOut])
#def list_fields(db: Session = Depends(get_db)):
#    return db.query(FieldModel).order_by(FieldModel.id.desc()).all()

#@app.get("/fields/{field_id}/advice")
#async def advice_by_id(field_id: int, db: Session = Depends(get_db)):
#    rec = db.query(FieldModel).get(field_id)
#    if not rec:
#        raise HTTPException(status_code=404, detail="Field not found")
#    wx = await fetch_weather(rec.centroid_lat, rec.centroid_lon)
#    return make_advice_payload(rec.name, rec.crop, rec.centroid_lat, rec.centroid_lon, rec.last_irrigation_ts, wx)
